package com.sist.exam;
/*
 *  생성자
 *     1)모든 생성자의 이름은 클래스의 이름과 동일해야한다.
//	   2)생성자는 객체를 생성하기 위한 것이다.(X) ==new가 담당
//	   5)생성자는 오버로딩을 할 수 있다
 *     *** 오버로딩의 조건
 *      = 한개의 클래스나 상속 관계의 클래스
 *      = 메소드명 동일
 *      = 매개변수의 갯수나 데이터형이 다름
 *      = 리턴형은 관계 없다
 *      
 *      this
 *      ----
 *      1) 모든 클래스는 this를 가지고 있다
 *      2) 객체 자신을 가리키는 참조변수 (static Object this) => new
 *         => this는 생성자, 인스턴스메소드에서 사용이 가능
 *         class A
 *         {
 *           public A(A this)
 *           {
 *           }
 *           public void display(A this)   // 매개변수안에  this가 존재한다
 *           {
 *           }
 *           public static void aaa() // static 메소드안에는 존재하지 않는다
 *           {
 *           }
 *      3) 지역변수와 인스턴스 변수를 구분할 때 사용한다
 *      4) 클래스 메소드(static)내에서는 사용할 수 없다
 *         
 *         인스턴스메소드 , 객체메소드
 *         객체명.메소드
 *         정적메소드, 공유메소드, 클래스메소드
 *          클래스명.메소드
 *     -----------------------------------------------------
 *     오버로딩 조건
 *     1) 메소드명이 동일 (한개의 이름으로 여러개의 새로운 기능을 추가)
 *     2) 매개변수의 갯수나 데이터형이 달라야 한다
 *     3) 리턴형 관계 없음
 * 
 */
class A
{
	int a=10;
	static int b=20;
	
	{
		a=100;
		System.out.println("a="+a);
	}
	static
	{
		b=200;
		System.out.println("b="+b);
	}
	A(){
		a=1000;
		b=2000;
		System.out.println("a="+a+",b="+b);
	}
}
public class 문제2 {
//	class PlayingCard { 
//		int kind; 
//		int num; 
//		static int width; 
//		static int height; 
//		PlayingCard(int k, int n) { 
//		kind = k; 
//		num = n; 
//	
//
//		} 
	public static void main(String[] args) {
			A a=new A();
		
		}
//		인스턴스변수 : kind, num
//		정적변수(공유변수) : width,height
//		지역변수 :k,n     (메소드에서 선언되는 변수 (지역변수,매개변수) = 메소드 안에서만 사용({}을 벗어나면 사라진다)
//		                                                    = 반드시 초기화 후 사용
//		
//		 다음 중 생성자에 대한 설명으로 옳지 않은 것은? (모두 고르시오)  b,c,e
		
//				a. 모든 생성자의 이름은 클래스의 이름과 동일해야한다.
//				 b. 생성자는 객체를 생성하기 위한 것이다. ==new가 담당
//				 c. 클래스에는 생성자가 반드시 하나 이상 있어야 한다.
//				 d. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.
//				 e. 생성자는 오버로딩 할 수 없다.
//				 
//				 
//다음 중 this에 대한 설명으로 맞지 않은 것은? (모두 고르시오) b
//			a. 객체 자신을 가리키는 참조변수이다.
//			 b. 클래스 내에서라면 어디서든 사용할 수 있다.
//		     c. 지역변수와 인스턴스변수를 구별할 때 사용한다.
//			 d. 클래스 메서드 내에서는 사용할 수 없다.
//						 
//
// 다음 중 오버로딩이 성립하기 위한 조건이 아닌 것은? (모두 고르시오) c,d
//a. 메서드의 이름이 같아야 한다.
//b. 매개변수의 개수나 타입이 달라야 한다.
//c. 리턴타입이 달라야 한다.
//d. 매개변수의 이름이 달라야 한다.
//
//오버로딩의 조건
//1. (   메소드 ) 이름이 같아야 한다.
//2. (    매개변수   )의 개수 또는 타입이 달라야 한다.
//3. 매개변수는 같고 (    매개변수이름  )이 다른 경우는 오버로딩이 성립되지 않는다.   
//
//
//long add(int a, int b) { return a+b; }       답: b,c,d
//a. long add(int x, int y) { return x+y; } (x)
//b. long add(long a, long b) { return a+b; }
//c. int add(byte a, byte b) { return a+b; }
//d. int add(long a, int b) { return (int)(a+b); }

//		 다음 중 초기화에 대한 설명으로 옳지 않은 것은? (모두 고르시오) e
//				a. 멤버변수는 자동 초기화되므로 초기화하지 않고도 값을 참고할 수 있다.
//		            ---- 인스턴스변수,정적변수 => 자동 초기화  (String,클래스,배열 = null값으로 초기화) (null= 참조하는 주소가 없다)
//				b. 지역변수는 사용하기 전에 반드시 초기화해야 한다.
		//      (지역변수는 자동 초기화가 안된다)
//				c. 초기화 블럭보다 생성자가 먼저 수행된다.
		       //명시적 초기화 => 초기화 블록 => 생성자
		       //               클래스변수=> 인스턴스변수
//				d. 명시적 초기화를 제일 우선적으로 고려해야 한다.
//				e. 클래스변수보다 인스턴스변수가 먼저 초기화된다.
		   //      ------- 컴파일시 ------new

						 
//		 다음 중 인스턴스변수의 초기화 순서가 올바른 것은? a
//				a. 기본값-명시적초기화-초기화블럭-생성자
//				b. 기본값-명시적초기화-생성자-초기화블럭
//				c. 기본값-초기화블럭-명시적초기화-생성자
//				d. 기본값-초기화블럭-생성자-명시적초기화

//		 다음 중 지역변수에 대한 설명으로 옳지 않은 것은? (모두 고르시오) a,d,e
//				a. 자동 초기화되므로 별도의 초기화가 필요없다.(x)
//				b. 지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다.
//				c. 메서드의 매개변수로 선언된 변수도 지역변수이다.
//				d. 클래스변수나 인스턴스변수보다 메모리 부담이 적다.(X)
//				e. 힙(heap)영역에 생성되며 가비지 컬렉터에 의해 소멸된다.(X)
	
//	
//	 다음 중 접근제어자를 접근범위가 넓은 것에서 좁은 것의 순으로 바르게 나열한 것은? a
//			a. public-protected-(default)-private
//			b. public-(default)-protected-private
//			c. (default)-public-protected-private
//			d. private-protected-(default)-public
	
//	접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
//	(    private ) - 같은 클래스 내에서만 접근이 가능하다.
//	(   default  ) - 같은 패키지 내에서만 접근이 가능하다.
//	(   protected  ) - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
//	(  public   ) - 접근 제한이 전혀 없다.
	
//	다음 중 접근 제어자에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
//			a. public은 접근제한이 전혀 없는 접근 제어자이다.
//			b. (default)가 붙으면, 같은 패키지 내에서만 접근이 가능하다.
//			c. 지역변수에도 접근 제어자를 사용할 수 있다.
	   //      ------
	   //       지역변수는 static, 접근지정어, abstract는 사용이 불가능
	   //        지역변수중에 유일하게 사용: final
//			d. protected가 붙으면, 같은 패키지 내에서도 접근이 가능하다.
//			e. protected가 붙으면, 다른 패키지의 자손 클래스에서 접근이 가능하다.







}
